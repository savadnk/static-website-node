/**
 * @callback FilterFn
 * @param {string} name
 * @param {PropertyDescriptor} descriptor
 * @returns {any} include it return value directly or return undefined
 */
/**
 *
 * @param {Function} ctor the class that needs to mixin from the `superCtor` class.
 * @param {Function} superCtor The super class that the `ctor` needs to inherit from.
 * @param {FilterFn|string[]|filterOpts=} options.filter (optional) A filter that specifies which members to include
 *   from the superCtor.
 *
 *   * This can be a function that takes a `name` and `value` parameter and returns a value to include or `undefined`
 *   * an array of strings that represent member names to include
 *   * or the filter options (`filterOpts`) available (`all`, `errSuper`, or `skipSuper`)
 *     * `all`: include all members from the superCtor without check whether the method used the `super()`.
 *     * `errSuper`: Throw error if the method of superCtor using the `super()`
 *     * `skipSuper`: skip the method if the method of superCtor using the `super()`
 *
 * @returns return true if successful
 */
export function mixin(ctor: Function, superCtor: Function, options: any): boolean;
/**
 * Mixes the methods and properties from one or more classes to the target class.
 *
 * By default, all properties and methods from the `superCtors` will be cloned into the internal `mixinCtor_`
 * constructor of the target class(`ctor`). This can be customized by providing the `options.filter` parameter.
 *
 * If the target class does not already have a `mixinCtor_` constructor it'll create the new constructor
 * `mixinCtor_` which is then inherited by the `ctor`(target class). The `mixinCtor_` is also set as a property of the
 * `ctor`.
 *
 * **Note**:
 *
 * 1. If a property or method exists with the same name in both `superCtors` and `ctor`'s `mixinCtor_`, the property
 *    or method in the `superCtor` takes precedence. The last one will overwrite the previous one.
 * 2. the `mixin` does not create a prototype chain between "`superCtors`"(just copy the members from `superCtors`), so
 *    you cannot clone these methods of `superCtor` which use the `super()`. If you need to use `super()` in these
 *    methods, you should use `inherits` instead of `mixin`.
 *
 * @param {Function} ctor the target class that needs to mixin from the `superCtors` class.
 * @param {Function|Function[]} superCtors The class(es) to be used as sources of properties and methods.
 * @param {FilterFn|string[]|filterOpts=} options.filter (optional) A filter that specifies which members to include
 *   from the `superCtor`. If no filter is specified, all properties and methods from `superCtor` will be mixed in.
 *
 *   * It could be a function that takes a `name` and `descriptor` parameter and returns true to include or `undefined`
 *   * Or an array of strings that represent member names to include
 *   * Or the filter options (`filterOpts`) available (`all`, `errSuper`, or `skipSuper`)
 *     * `all`: include all members from the superCtor without check whether the method used the `super()`.
 *     * `errSuper`: Throw error if the method of superCtor using the `super()`
 *     * `skipSuper`: skip the method if the method of superCtor using the `super()`
 *
 * @returns return true if successful
 *
 * @example
 *
 * class MixinA {
 *   methodA() {
 *     console.log('Method A called');
 *   }
 * }
 *
 * class MixinB {
 *   methodB() {
 *     console.log('Method B called');
 *   }
 * }
 *
 * class MyClass {
 *   constructor() {
 *   }
 * }
 *
 * // mixin both MixinA and MixinB
 * mixins(MyClass, [MixinA, MixinB]); // == mixins(MyClass, MixinA); mixins(MyClass, MixinB);
 *
 * const myObj = new MyClass();
 *
 * myObj.methodA(); // logs 'Method A called'
 * myObj.methodB(); // logs 'Method B called'
 */
export function mixins(ctor: Function, superCtors: Function | Function[], options: any): boolean;
export namespace mixins {
    export { filterOpts };
}
/**
 * Enum for filter type
 */
export type filterOpts = number;
export namespace filterOpts {
    const all: number;
    const errSuper: number;
    const skipSuper: number;
}
export default mixins;
export type FilterFn = (name: string, descriptor: PropertyDescriptor) => any;
