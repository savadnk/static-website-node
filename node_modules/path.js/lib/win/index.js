"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.WinPath = void 0;
var _utilEx = require("util-ex");
var _path = require("../path");
const splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/.]+[\\\/]+[^\\\/.]+)?([\\\/])?([\s\S]*?)$/;
const splitTailRe = /^([\s\S]*?)((?:\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))(?:[\\\/]*)$/;

/**
 * A subclass of `Path` that provides functionality specific to Windows file systems.
 *
 */
class WinPath extends _path.Path {
  constructor() {
    super({
      sep: '\\',
      delimiter: ';'
    });
  }
  /**
   * Retrieves the current working directory by calling `process.cwd()` and normalizing
   * the path for Windows by replacing any consecutive slashes or backslashes with a single backslash.
   *
   * @memberof WinPath
   * @instance
   * @returns {string} - The normalized current working directory for Windows.
   */
  cwd() {
    return process.cwd().replace(/[\\\/]+/g, '\\');
  }
  /**
   * Checks if two directory paths are the same, ignoring case differences.
   *
   * @memberof WinPath
   * @instance
   * @param {string} aDir1 - The first directory path to compare.
   * @param {string} aDir2 - The second directory path to compare.
   * @returns {boolean} - `true` if the paths are the same (case-insensitive), `false` otherwise.
   */
  _isSame(aDir1, aDir2) {
    return aDir1.toLowerCase() === aDir2.toLowerCase();
  }
  /**
   * Normalizes a UNC root path by removing leading slashes or backslashes and replacing
   * any consecutive slashes or backslashes with a single backslash.
   *
   * @memberof WinPath
   * @instance
   * @param {string} device - The UNC root path to normalize.
   * @returns {string} - The normalized UNC root path.
   */
  normalizeUNCRoot(device) {
    return '\\\\' + device.replace(/^[\\\/]+/, '').replace(/[\\\/]+/g, '\\');
  }
  /**
   * Converts a given path into an array of path segments.
   *
   * @memberof WinPath
   * @instance
   * @param {string} aPath - The path to convert.
   * @returns {string[]} - An array containing the path segments.
   */
  toArray(aPath) {
    /*
    while aPath.length and aPath[0] is _sep
      aPath = aPath.substring(1)
    while aPath.length and aPath[aPath.length - 1] is _sep
      aPath = aPath.substring(0, aPath.length - 1)
      */
    var arr, result, root;
    if (aPath && aPath.length) {
      arr = this.splitPath(aPath);
      root = arr[0];
      result = this.trimArray(arr[1].split(/[\\\/]+/));
      if (root && (root !== '\\' || root !== '/')) {
        result.unshift(root);
      }
      result.push(arr[2]);
      result;
    } else {
      result = [];
    }
    return result;
  }
  /**
   * Splits a given path into its device, directory, base, and extension components.
   *
   * @memberof WinPath
   * @instance
   * @param {string} filename - The path to split.
   * @returns {string[]} - An array containing the device, directory, base, and extension components.
   */
  splitPath(filename) {
    var basename, device, dir, ext, result, result2, tail;
    result = splitDeviceRe.exec(filename);
    device = (result[1] || '') + (result[2] || '');
    tail = result[3] || '';
    result2 = splitTailRe.exec(tail);
    dir = result2[1];
    basename = result2[2];
    ext = result2[3];
    return [device, dir, basename, ext];
  }
  /**
   * Analyzes a given path and returns an object containing information about it.
   *
   * @memberof WinPath
   * @instance
   * @param {string} path - The path to analyze.
   * @returns {{device: string, isUnc: boolean, isAbsolute: boolean, tail: string}} - An object containing device, isUnc, isAbsolute, and tail properties.
   */
  statPath(path) {
    var device, isUnc, result;
    result = splitDeviceRe.exec(path);
    device = result[1] || '';
    isUnc = !!device && device[1] !== ':';
    return {
      device: device,
      isUnc: isUnc,
      isAbsolute: isUnc || !!result[2],
      tail: result[3]
    };
  }
  /**
   * Determines whether a given path is absolute.
   *
   * @memberof WinPath
   * @instance
   * @param {string} path - The path to check.
   * @returns {boolean} - `true` if the path is absolute, `false` otherwise.
   */
  isAbsolute(path) {
    return this.statPath(path).isAbsolute;
  }
  /**
   * Makes a long Windows path from a given path.
   *
   * @memberof WinPath
   * @instance
   * @param {string} path - The path to convert.
   * @returns {string} - The long Windows path representation.
   */
  _makeLong(path) {
    var resolvedPath, result;
    if (!(0, _utilEx.isString)(path)) {
      return path;
    }
    if (!path) {
      return '';
    }
    resolvedPath = this.resolve(path);
    if (/^[a-zA-Z]\:\\/.test(resolvedPath)) {
      result = '\\\\?\\' + resolvedPath;
    } else if (/^\\\\[^?.]/.test(resolvedPath)) {
      result = '\\\\?\\UNC\\' + resolvedPath.substring(2);
    } else {
      result = path;
    }
    return result;
  }
  /**
   * Joins all given path segments into a single path, taking into account Windows-specific rules.
   *
   * @memberof WinPath
   * @instance
   * @param {...string} paths - The path segments to join.
   * @returns {string} - The joined path.
   */
  join() {
    var result;
    result = this._join.apply(this, arguments);
    if (!/^[\\\/]{2}[^\\\/]/.test(result[0])) {
      result = result.join(this._sep);
      result = result.replace(/^[\\\/]{2,}/, '\\');
    } else {
      result = result.join(this._sep);
    }
    return this.normalize(result);
  }
  /**
   * Normalizes a given path, resolving '.' and '..' segments, and ensuring correct slashes for Windows.
   *
   * @memberof WinPath
   * @instance
   * @param {string} path - The path to normalize.
   * @returns {string} - The normalized path.
   */
  normalize(path) {
    var device, isAbsolute, isUnc, result, tail, trailingSlash;
    result = this.statPath(path);
    device = result.device;
    isUnc = result.isUnc;
    isAbsolute = result.isAbsolute;
    tail = result.tail;
    trailingSlash = /[\\\/]$/.test(tail);
    tail = this.normalizeArray(tail.split(/[\\\/]+/), !isAbsolute).join('\\');
    if (!tail && !isAbsolute) {
      tail = '.';
    }
    if (tail && trailingSlash) {
      tail += this._sep;
    }
    if (isUnc) {
      device = this.normalizeUNCRoot(device);
    }
    return device + (isAbsolute ? '\\' : '') + tail;
  }
  /**
   * Resolves a sequence of paths or path segments into an absolute path, considering Windows-specific rules.
   *
   * @memberof WinPath
   * @instance
   * @param {...(string|string[])} paths - Paths or path segments to resolve.
   * @returns {string[]} - An array representing the resolved absolute path.
   */
  resolveArray() {
    var i, isUnc, resolveAbsolutePath, resolvedAbsolute, resolvedDevice, resolvedPath, tail, vCwd, vPath, vpath;
    resolvedPath = [];
    resolvedDevice = '';
    resolvedAbsolute = false;
    isUnc = false;
    tail = '';
    resolveAbsolutePath = function (_this) {
      return function (aPath) {
        var device, result, st;
        st = _this.statPath(aPath);
        device = st.device;
        if (device && resolvedDevice && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
          return false;
        }
        isUnc = st.isUnc;
        if (!resolvedDevice) {
          resolvedDevice = device;
        }
        tail = st.tail;
        result = resolvedAbsolute;
        if (!resolvedAbsolute) {
          resolvedAbsolute = st.isAbsolute;
        }
        return !result;
      };
    }(this);
    vCwd = this.cwd();
    i = arguments.length;
    while (--i >= -1 && !(resolvedAbsolute && resolvedDevice)) {
      if (i >= 0) {
        vPath = arguments[i];
      } else if (!resolvedDevice) {
        vPath = vCwd;
      } else {
        vpath = typeof process === 'object' && process.env['=' + resolvedDevice];
        if (!vpath || vpath.substr(0, 3).toLowerCase() !== resolvedDevice.toLowerCase() + '\\') {
          vpath = resolvedDevice + '\\';
        }
      }
      if ((0, _utilEx.isArray)(vPath)) {
        if (vPath.length === 0) {
          resolvedAbsolute = true;
        } else {
          if (resolveAbsolutePath(vPath[0])) {
            resolvedPath = vPath.slice(1).filter(Boolean).concat(resolvedPath);
          }
        }
        continue;
      } else if (vPath == null) {
        continue;
      } else if (!(0, _utilEx.isString)(vPath)) {
        throw new TypeError('Arguments to path.resolve must be string or array');
      }
      if (resolveAbsolutePath(vPath)) {
        resolvedPath = tail.split(/[\\\/]+/).filter(Boolean).concat(resolvedPath);
      }
    }
    if (isUnc) {
      resolvedDevice = this.normalizeUNCRoot(resolvedDevice);
    }
    resolvedPath = this.normalizeArray(resolvedPath, !resolvedAbsolute);
    resolvedDevice = resolvedDevice + (resolvedAbsolute ? this._sep : '');
    resolvedPath.unshift(resolvedDevice ? resolvedDevice : '.');
    return resolvedPath;
  }
  /**
   * Computes the relative path from one path to another, considering Windows-specific rules.
   *
   * @memberof WinPath
   * @instance
   * @param {string} from - The starting path.
   * @param {string} to - The destination path.
   * @returns {string} - The relative path from `from` to `to`.
   */
  relative(from, to) {
    var fromParts, i, length, outputParts, samePartsLength, toParts, vPathSep;
    vPathSep = this._sep;
    fromParts = this.resolveArray(from);
    toParts = this.resolveArray(to);
    length = Math.min(fromParts.length, toParts.length);
    samePartsLength = length;
    i = -1;
    while (++i < length) {
      if (!this._isSame(fromParts[i], toParts[i])) {
        samePartsLength = i;
        break;
      }
    }
    if (!samePartsLength) {
      return this.join(toParts);
    }
    outputParts = [];
    i = samePartsLength;
    while (i < fromParts.length) {
      outputParts.push('..');
      i++;
    }
    outputParts = outputParts.concat(toParts.slice(samePartsLength));
    return outputParts.join(vPathSep);
  }
}
exports.WinPath = WinPath;
var _default = exports.default = WinPath;