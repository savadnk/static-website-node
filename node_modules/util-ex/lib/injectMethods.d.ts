/**
 * Injects multiple methods into an object, optionally preserving access to the original methods via "`super`" and original instance via "`self`".
 *
 * **Note**:
 *
 * * In the new replaced method, you can use `this.super()` to call the original method, `this.super()` is already bind with original instance.
 * * The `this[aMethodName]` is the original method, but not bind yet.
 * * `this.self` is the original instance!
 *
 * @param {object} aObject - The target object to inject methods into.
 * @param {object} aMethods - The methods to inject into the aObject.
 * @param {object=} [aOptions] - The optional parameters.
 * @param {{[name: string]:boolean}=} [aOptions.replacedMethods] - The methods that should be replaced in the aObject.
 * @returns {boolean} Whether the injections are successful.
 *
 * @example
 * var obj = {
 *   method1: function() {
 *     console.log('Hello');
 *   },
 *   method2: function() {
 *     console.log('World');
 *   }
 * };
 *
 * var newMethods = {
 *   method1: function() {
 *     this.super();
 *     console.log('New Hello');
 *   },
 *   method3: function() {
 *     console.log('New World');
 *   }
 * };
 *
 * injectMethods(obj, newMethods, { replacedMethods: { method2: true } });
 *
 * obj.method1(); // Output: Hello\nNew Hello
 * obj.method2(); // Output: World
 * obj.method3(); // Output: New World
 */
export function injectMethods(aObject: object, aMethods: object, aOptions?: object | undefined): boolean;
export default injectMethods;
